#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Virtual_Ensemble.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1oTiETsnT1gd7Ta2nSIguzsQrhQmhF0Ia
# VIRTUAL MUSIC ENSEMBLE TECHNOLOGIES, LLC.
## -- Desktop Application Prototype --
IMPORTANT: All code must be kept strictly confidential and not shared with anyone outside the company.
#Saving Instructions:
+Do not edit the master copy: "Virtual_Ensemble.ipynb".
+Instead make a copy to your folder within the engineering folder.
+Name your copy: "VMET_yourinitials_month_day.ipynb"
--->for example: "VMET_BE_06_05.ipynb".
+Create a new copy to work on at the start of each editing session.
+We'll add to the master copy only when code sections are working well.
# Links:
https://github.com/MalFan/tile-videos/blob/master/tile_videos.py
https://github.com/xaliceli/video-mosaic
https://opencv.org/
"""

#General Imports
import numpy as np
# import matplotlib.pyplot as plt
# from google.colab import output
import cv2
import math
import random
import sys
from scipy import ndimage
import os
import time
import subprocess
# from google.colab import files
# from google.colab.patches import cv2_imshow
# import moviepy.editor as mp
from moviepy.video.io.VideoFileClip import VideoFileClip
from moviepy.video.fx import resize
# weird pyinstaller error
import shutil
import skimage.transform as st
from functools import partial
# import sox
from pydub import AudioSegment

#Frame Counting Import
#!pip install --upgrade imutils
import imutils
from imutils import video
from imutils.video import count_frames
from tempfile import gettempdir

#Audio Mixing Import
#!pip install ffmpeg #note ! ONLY FOR COLAB
#!apt-get install sox libsox-fmt-mp3
global PROG
PROG = 0
global PERCENT
PERCENT = 0
global ACTION
ACTION = "Resizing videos..."
global FFMPEG_DIR
FFMPEG_DIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), "./ffmpeg/ffmpeg.exe")
# NOTE:Change to the following directory for packaing
# FFMPEG_DIR = "./ffmpeg/ffmpeg.exe"
global FOLDERPATH
FOLDERPATH = os.path.join(gettempdir(), 'tiles')

class Processor: 
    def __init__(self, files, **kwargs):
        super(Processor, self).__init__(**kwargs)
        self.FILES = files
        #self.IMG_COUNT = img_count

    """ ## 1.) Import Video Files"""

    """## 2.) Create Rescaled Videos in Temp Folder"""

    def tile_dim(self, num_vid, dimensions):
        """Calculates the dimensions of one tile based on number of videos and final video dimensions"""

        ##if (num_vid == 2):
            ##height = np.floor(dimensions[1])
            ##width = np.floor(dimensions[0] / 2)

        #Assume perfect squares as grids, could become more advanced
        ##else:
        size = np.ceil(np.sqrt(num_vid))
            #height = np.floor(dimensions[1] / size)
            #width = np.floor(dimensions[0] / size)
        height = dimensions[1]/size
        width = dimensions[0]/size
        return height, width

    def resize_vid(self, vid, folder, h, w, vid_id):
        """Resizes a single video and outputs to new folder"""

        print("path: ", vid)
        # clip = mp.VideoFileClip(vid)
        clip = VideoFileClip(vid)
        resized = resize.resize(clip, height = h) # Width is computed so that the width/height ratio is conserved.)

        #Write new resized video
        resize_path = os.path.join(folder, str(vid_id) + '.mp4') #path and name for resized vid, ex: "./tile/3.mp4"
        os.chmod(os.path.dirname(os.path.realpath(__file__)), 0o0777)
        resized.write_videofile(resize_path, temp_audiofile=os.path.join(folder,str(vid_id)+'_temp.mp4')) # Write new video into tiles folder

    def resize_all(self, vid_path='./recordings/test'):
        """Resizes all videos in folder to new folder"""
        global FOLDERPATH

        print('----------------------------')
        print('Resizing videos...')
        print('----------------------------')

        # Create new folder for resized videos
        if not os.path.isdir(FOLDERPATH):
            os.mkdir(FOLDERPATH)
            os.chmod(FOLDERPATH,0o0777)

        # Find number of videos
        num_vid = 0
        #for filename in os.listdir(vid_path):
            #num_vid = num_vid + 1
        for filename in self.FILES:
            num_vid = num_vid + 1
        print('Num: ', num_vid)

        # Find tile dimensions
        dimensions = np.array([1280, 720])
        height, width = self.tile_dim(num_vid, dimensions)
        height = int(height)
        width = int(width)
        print('Dim: ', height, width)

        # Resize videos and save into folder
        vid_id = 1
        #for filename in os.listdir(vid_path):
        for filename in self.FILES:
            self.resize_vid(filename, FOLDERPATH, height, width, vid_id)
            vid_id = vid_id + 1

        return num_vid, height, width

    """## 3.) Create Tiled Video"""

    def get_blank(self, width, height, rgb_color = (0,0,0)):
        """Create placeholder blank frame (numpy array) filled with black color"""

        # Create black blank image
        blank = np.zeros((height, width, 3), np.uint8)

        # Since OpenCV uses BGR, convert the color first
        color = tuple(reversed(rgb_color))

        # Fill image with color
        blank[:] = color

        return blank

    def tile_frame(self, img, num_vid, tile_height, tile_width, num_frames, total):
        """Creates one tiled video frame from input frames"""
        #if (num_vid ==2): # Special case of 2 videos
            #frame = np.concatenate((img[0], img[1]), axis=1

        #else: # All other cases

        # Determine parameters of tile array
        size = np.ceil(np.sqrt(num_vid)) #num of images for each row and col
        size = size.astype(int)
        num_full = np.floor(num_vid / size) #num of full rows
        num_full = num_full.astype(int)
        last_imgs = num_vid % size #num of images in bottom partial row
        if(last_imgs == 0 and num_full == size):
            blanks = 0
        else:
            blanks = size - last_imgs #num of blank tiles in bottom partial row
        tile_size = np.shape(img[0]) #dim of 1 tile
        row_size = np.array((tile_size[0], tile_size[1]*size, tile_size[2])) #dim of row of tiles
        row_size = row_size.astype(int)

        # First fill all the full rows
        im_num = 0 #Keep track of which image index to add
        full_rows = np.empty(row_size)
        for row in range(num_full):
            temp = img[im_num]
            im_num = im_num + 1
            for col in range(size-1):
                temp = np.concatenate((temp, img[im_num]), axis=1)
                im_num = im_num + 1
            full_rows = np.concatenate((full_rows, temp), axis=0)

        if(blanks != 0):
            # Then add images to last partial row
            last_row = np.empty(tile_size)
            for im in range(last_imgs):
                last_row = np.concatenate((last_row, img[im_num]), axis=1)
                im_num = im_num + 1

            # Then add blanks to partial row
            blank_tile = self.get_blank(tile_width, tile_height)
            for blank in range(blanks):
                last_row = np.concatenate((last_row, blank_tile), axis=1)
            # Trim last row, first column
            last_row = last_row[:, tile_width:, :]
            # Finally concatenate last row to full rows
            frame = np.concatenate((full_rows, last_row), axis=0)

            #ADDED: add another row of blanks if needed - same process
            if(size - num_full > 1):
                blank_row = np.empty(tile_size)
                blank_tile = self.get_blank(tile_width, tile_height)
                for blank in range(size):
                    blank_row = np.concatenate((blank_row, blank_tile), axis=1)
                blank_row = blank_row[:, tile_width:, :]
                frame = np.concatenate((frame, blank_row), axis=0)
        else:
            frame = full_rows
        # Trim entire first row
        frame = frame[tile_height:, :, :]
        frame = st.resize(frame, (720, 1280))
        self.prog(total)
        return frame

    def tile_video(self, num_vid, height, width, output_file, num_frames, total):
        global ACTION
        ACTION = "Tiling video..."
        """Create tiled video output"""
        global FOLDERPATH
        print('----------------------------')
        print('Tiling video...')
        print('----------------------------')

        #Set video folder location
        vid_path = FOLDERPATH

        #Count number of frames in first video (assumes each video has same number of frames)
        #first = os.listdir(vid_path)[0]
        #first_path = self.FILES[0]
        #first_path = vid_path + first
        #num_frames = count_frames(first_path, False)
        print(num_frames)
        #Initialize final video storage
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        #PREVIOUSLY ./recordings/video_temp.mp4
        video=cv2.VideoWriter(os.path.join(FOLDERPATH,output_file), fourcc, 30, (1280,720), True)

        #Tile video frame by frame
        #NOTE:Change range for quicker testing
        for fm in range(num_frames): #loop through each frame (set range to num_frames to run full length)
            images = np.empty((num_vid, height, width, 3)) #initialize array to hold a single image from each video
            idx = 0
            print(os.listdir(vid_path))
            for filename in os.listdir(vid_path): #loop through each video
                if filename != output_file:
                    vd = os.path.join(vid_path, filename) #concatenate folder and file names
                    vidcap = cv2.VideoCapture(vd) #create video object
                    vidcap.set(1, fm) #set video frame to frame number
                    print("Sizes:")
                    print(np.shape(images[idx, :, :, :]))
                    _, image = vidcap.read() #get frame
                    print(np.shape(image))
                    images[idx, :, :, :] = image
                    idx += 1
            frame = self.tile_frame(images, num_vid, height, width, num_frames, total)
            frame = np.uint8(frame)
            video.write(frame)
        video.release()

    """## 4.) Mix Audio Channels"""

    def mix_audio(self, audio_file, total):
        global ACTION
        global FFMPEG_DIR
        global FOLDERPATH
        ACTION = "Mixing audio..."
        print('----------------------------')
        print('Mixing audio...')
        print('----------------------------')
        delayed_audios = []
        audios = []
        offset = 0
        #audio_file = vid_path + audio_file

        flist = []
        #for filename in os.listdir(vid_path):
        for filename in self.FILES:
            if (filename == '.ipynb_checkpoints'):
                #do nothing; to avoid issues with colab
                z = 0
            elif (filename not in flist):
                #video_file = os.path.join(vid_path, filename)
                video_file = filename
                print(filename)
                mp4_file = video_file
                file_name = video_file.split('.')[0]
                wav_file = file_name + '.wav'
                print(wav_file)

                # Extract audio (check github if wanting to trim videos)
                if os.path.isfile(wav_file):
                    os.remove(wav_file)
                subprocess.call('%s -i "%s" -b:a 192K -vn "%s"' % (self.resource_path(FFMPEG_DIR), mp4_file, wav_file), shell=True)
                audios.append(wav_file)
            flist.append(filename)
        
        assert len(audios) > 0, "There's no temporary audio tracks!"

        if(len(audios) == 1):
            shutil.copy(audios[0], audio_file)
        else:


            # # subprocess.call('sox -m %s %s' % (' '.join(audios), audio_file), shell=True)\
            # sample_rate = 44100
            # # create combiner
            # cbn = sox.Combiner()
            # cbn.convert(samplerate=sample_rate, n_channels=2)
            # # create the output file
            # cbn.build(
            #     audios, audio_file, 'mix-power'
            # )
            mix_path = os.path.join(FOLDERPATH, 'audio_temp.wav')
            mixed = AudioSegment.from_wav(audios[0])
            for audio in audios[1:]:
                mixed = AudioSegment.from_wav(audio).overlay(mixed)
            mixed.export(mix_path,"wav")


        #Remove separate mp3 files
        # for audio in audios:
        #     subprocess.call('rm %s' % (audio), shell=True)
        for audio in audios:
            if os.path.isfile(audio):
                os.remove(audio)
            
        self.prog(total)

    """## 5.) Final Output Video"""

    def combine(self, video_file, audio_file, output_file, total):
        global ACTION
        global FFMPEG_DIR
        global FOLDERPATH
        ACTION = "Combining video and audio..."
        print('----------------------------')
        print('Combining video and audio...')
        print('----------------------------')
        print(output_file)
        # audio_path = './recordings/test/' + audio_file
        # video_path = './recordings/' + video_file
        # output_path = './recordings/' + output_file
        desktop = os.path.join(os.path.expanduser('~'), 'Desktop')
        print(desktop)
        video_file_path = os.path.join(FOLDERPATH,video_file)
        audio_file_path = os.path.join(FOLDERPATH,audio_file)
        output_file_path = os.path.join(FOLDERPATH,output_file)
        subprocess.call('%s -i "%s" -i "%s" -shortest "%s"' % (self.resource_path(FFMPEG_DIR),video_file_path,audio_file_path,output_file_path), shell=True)
        shutil.copy(output_file_path, desktop)
        print('here')
        self.prog(total)

    def remove_temp_files(self, video_file, audio_file, filename=""):
        global ACTION
        ACTION = "Removing temporary files..."
        global FOLDERPATH
        print('----------------------------')
        print('Removing temporary files...')
        print('----------------------------')
        # audio_path = './recordings/test/' + audio_file
        # video_path = './recordings/' + video_file

        # subprocess.call('rm %s' % (video_file), shell=True)
        # subprocess.call('rm %s' % (audio_file), shell=True)
        # subprocess.call('rm %s' % (filename), shell=True)
        video_file_path = os.path.join(FOLDERPATH,video_file)
        audio_file_path = os.path.join(FOLDERPATH,audio_file)
        filename_path = os.path.join(FOLDERPATH,filename)
        if os.path.isfile(video_file_path):
            os.remove(video_file_path)
        if os.path.isfile(audio_file_path):
            os.remove(audio_file_path)
        if os.path.isfile(filename_path):
            os.remove(filename_path)
        if os.path.isdir(FOLDERPATH):
            shutil.rmtree(FOLDERPATH)
        # for x in range(self.IMG_COUNT):
        #     name = 'test' + str(x) + '.png'
        #     os.remove(name)
        
    
    # Function that calculates progress
    def prog(self, total):
        global PROG
        global PERCENT
        PROG+=1
        PERCENT = int((PROG/total)*100)
        print(PROG)
        print(total)
        print(PERCENT)
    
    def resource_path(self,relative_path):
        """Helper function that redirects some module to packaged binaries instead from import
        ref: https://stackoverflow.com/questions/56370173/how-to-export-ffmpeg-into-my-python-program"""
        if hasattr(sys, '_MEIPASS'):
            # _MEIPASS is a temporary folder for pyinstaller
            return os.path.join(sys._MEIPASS, relative_path)
        return os.path.join(os.path.abspath("."), relative_path)

    #MAIN THAT CALLS ALL FUNCTIONS
    def run_app(self, filename):
        #self.unzip()
        print("----")
        print(self.FILES)
        print("----")
        # clean up legacy files
        self.remove_temp_files('video_temp.mp4', 'audio_temp.wav')

        #FOLDER = './Desktop/VMET/test/'
        DIM = (1920,1080)

        # Find number of videos
        num_vid = 0
        for count in self.FILES:
            num_vid+=1

        # Find number of frames in videos
        first = self.FILES[0]
        num_frames = count_frames(first, False)
        # Calculate total progress bar size
        print(num_frames)
        print(num_vid)
        total = num_frames + num_vid

        #add timestamp to output file name
        ts = int(time.time()/100)
        filename = filename + '_' + str(ts) + '.mp4'
        print(filename)
        
        num_vid, height, width = self.resize_all()

        self.tile_video(num_vid, height, width, 'video_temp.mp4', num_frames, total)

        self.mix_audio('audio_temp.wav', total)

        self.combine('video_temp.mp4', 'audio_temp.wav', filename, total) #FINAL WRITE

        self.remove_temp_files('video_temp.mp4', 'audio_temp.wav',filename)

        print('DONE')
        # NOTE used by App.js as an indicator of the completion 
